# MVM

mvm, magenta virtual machine, is a bytecode interpreter for magenta

code is written assuming the following type sizes:
(u)char  ==  8 bits
(u)short == 16 bits
(u)int   == 32 bits
(u)long  == 64 bits

# memory and io

magenta bytecode is stack based. memory, to the program running inside the vm,
seems like it is allocated in a long continuous stretch, in actuality it is not.

devices ids are ascii strings that can be passed into the io bus to access their
read/write streams. if an input command for a device states that it "returns"
something, then it is most likely writing to its output buffer.

devices are mapped as specified by these offsets:
  +0-7   -> input buffer, inputs are sent to the cpu byte by byte until a null
            byte is sent. read behavior is as expected, returning the last
            written byte
  +8-F   -> output buffer, outputs are received from the cpu byte by byte. the
            last byte you should receive in response to an input is null. write
            behavior is unspecified.
  +10-13 -> output buffer length, length of the output buffer, how many bytes
            you can read from the buffer before it is empty.

io bus [device] [no id, can't be created] [always mapped at 0x01-0x14]
  [0x01XX..YY..] request to open a device
    XX states how many bytes (the first ..) will be used to specify a device
    before YY, similarly YY states the byte width of the memory address (the
    second ..) to allocate the device to. returns a 1 byte if operation was
    successful, otherwise a 0 byte if not.
  [0x02YY..] request to close a device
    YY states the byte width of the memory address (the ..) the device was
    allocated at. returns a 1 byte if operation was successful, otherwise a 0
    byte if not.
  [0x03AABB..] memory management
    AA -> 00 (length)
      write the bytewidth of the following data and amount of available memory
      to output buffer. BB and .. are null bytes. returns a 1 byte if operation
      was successful, otherwise a 0 byte if not.
    AA -> 01 (dealloc)
      BB is bytewidth, .. is the amount of bytes to deallocate, returns a 1 byte
      if operation was successful, otherwise a 0 byte if not.
    AA -> 02 (alloc)
      BB is bytewidth, .. is the amount of bytes to allocate, returns a 1 byte
      if operation was successful, otherwise a 0 byte if not.

TODO: instead of directly accessing files as devices, have an intermediary
      "storage" device. (will be represented as a mounted directory on host)
      there should also be a way of listing storage devices through the io bus

file [device] [device id "FILEM:.."]
  [id]
    M is the mode the file is opened in. can be Read, Write, Mod, or Append. mod
    is equivalent to a hybrid read/write, whilst append is like write only but
    appending to end of another file. write/mod/append all create files, but
    only write wipes files.
    .. can be either a path to a file on the hard drive or a special file.
  [special files]
    special files to allow bytecode interoperability between VMs running on dif-
    errent platforms, these include the following:
      STD (R: stdin file, W: stdout file, M: both)
      STDERR (R: unspecified, W: stderr file, M: unspecified)
  [output buffer]
    the output buffer allows you to read a file (or std stream) byte by byte, in
    files (behavior for write only/actively written to read only files is not
    specified) you can set the 'output buffer length' to change the focused byte
    in the output buffer, moving to different parts of the file, where 0 is EOF.
  [input buffer]
    the input buffer allows you to write to a file (or std stream) byte by byte,
    in files (behavior for read only/actively written to read only files is not
    specified) if the file is in Mod mode,

# instructions/opcodes

if you see sN, that means top element of stack - N, s0 is the top element, s1 is
the second-to-top element, etc. if an action is performed with a stack element
and it is not pushing, then it is usually popping.

if you see bN, that means program counter (currently on the instruction) plus 1
and N, so b0 is the byte directly after the instruction, b1 is the byte second
after the instruction, etc.

by default, all instructions work with 1 byte (8 bits) at once, using flags you
can set the memory width to 2 bytes (16 bit), 4 bytes (32 bit), 8 bytes (64 bit)
, and revert to the default 1 byte/8 bit memory width. when a flag is set, it is
kept until another flag is encountered.

if the push instruction runs into 0xFF it will substitute it for a null byte.

add/subtract instructions will overflow if memory width is too small, you should
consider using a memory width one above the width of the numbers you pushed to
A and B if you would like to avoid integer overflows.

instructions marked with ! are not currently implemented.

 0x | opcode     | notes
----|------------|--------------------------------------------------------------
 00 | push       | push values to stack until null byte is reached
 01 | push bytes | following program bytes will be pushed to stack
 02 | pop to A   | pop byte(s) from stack to A register
 03 | pop to B   | pop byte(s) from stack to B register
 04 | convert #  | convert last memory width to ascii number string
----|------------|--------------------------------------------------------------
!05 | pointr set | sets memory pointer location to A
!06 | pointr loc | push memory pointer location to stack
!07 | pointr get | push memory data to stack, pushes as many bytes as width
!08 | pntr write | pop byte from stack and write it to mem address under pointer
!09 | pntr write | write B to memory address under pointer
----|------------|--------------------------------------------------------------
 0A | add        | push answer of A + B to stack
 0B | subtract   | push answer of A - B to stack
----|------------|--------------------------------------------------------------
!0C | greater    | if A isn't greater than B then jump to s0
!0D | greater/eq | if A isn't greater than or equal to B then jump to s0
!0E | equal      | if A isn't equal to B then jump to s0
 0F | jump       | set program counter to s0
 10 | jmp to sub | set program counter to s0 and push old counter to call stack
 11 | exit sub   | pop value from call stack and go to it
----|------------|--------------------------------------------------------------
 12 | 1byte flag | set memory width to 8 bits
 13 | 2byte flag | set memory width to 16 bits
 14 | 4byte flag | set memory width to 32 bits
 15 | 8byte flag | set memory width to 64 bits
----|------------|--------------------------------------------------------------
 16 | depop A    | pushes the value in A to stack without clearing A
 17 | depop B    | pushes the value in B to stack without clearing B
----|------------|--------------------------------------------------------------
 18 | exit       | exits the program
----|------------|--------------------------------------------------------------
 1E | debug      | logs contents of stack until null byte is reached
 1F | no op      |
----|------------|--------------------------------------------------------------
 0x | opcode     | notes
