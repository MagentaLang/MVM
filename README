# MVM

mvm, magenta virtual machine, is a bytecode interpreter for magenta

# special types

if the push instruction runs into 0xFF it will substitute it for a null byte.

# memory and io

magenta bytecode is stack based. memory, to the program running inside the vm,
seems like it is allocated in a long continuous stretch, in actuality it is not.

devices ids are ascii strings that can be passed into the io bus to access their
read/write streams.

devices are mapped as specified by these offsets:
  +0-7   -> input buffer, inputs are sent to the cpu byte by byte until a null
            byte is sent. read behavior is as expected, returning the last
            written byte
  +8-F   -> output buffer, outputs are received from the cpu byte by byte. the
            last byte you should receive in response to an input is null. write
            behavior is unspecified.
  +10-13 -> output buffer length, length of the output buffer, how many bytes
            you can read from the buffer before it is empty.

io bus [device] [no id, can't be created] [always mapped at 0x01-0x14]
  [0x01XX..YY..] request to open a device
    XX states how many bytes (the first ..) will be used to specify a device
    before YY, similarly YY states the byte width of the memory address (the
    second ..) to allocate the device to
  [0x02YY..] request to close a device
    YY states the byte width of the memory address (the ..) the device was
    allocated at
  [0x03AABB..] memory management
    AA -> 00 (length)
      write the bytewidth of the following data and amount of available memory to
      output buffer. BB and .. are null bytes.
    AA -> 01 (dealloc)
      BB is bytewidth, .. is the amount of bytes to deallocate, returns either a
      success or error code in output buffer.
    AA -> 02 (alloc)
      BB is bytewidth, .. is the amount of bytes to allocate, returns either a
      success or error code in output buffer.

file [device] [device id "FILEM:.."]
  [id]
    M is the mode the file is opened in. can be Read, Write, Mod, or Append. mod
    is equivalent to a hybrid read/write, whilst append is like write only but
    appending to end of another file. write/mod/append all create files, but
    only write wipes files.
    .. can be either a path to a file on the hard drive or a special file.
  [special files]
    special files to allow bytecode interoperability between VMs running on dif-
    errent platforms, these include the following:
      STD (R: stdin file, W: stdout file, M: both)
      STDERR (R: unspecified, W: stderr file, M: unspecified)
  [output buffer]
    the output buffer allows you to read a file (or std stream) byte by byte, in
    files (behavior for write only/actively written to read only files is not
    specified) you can set the 'output buffer length' to change the focused byte
    in the output buffer, moving to different parts of the file, where 0 is EOF.
  [input buffer]
    the input buffer allows you to write to a file (or std stream) byte by byte,
    in files (behavior for read only/actively written to read only files is not
    specified) if the file is in Mod mode,


# instructions/opcodes

if you see sN, that means top element of stack - N, s0 is the top element, s1 is
the second-to-top element, s2 is the third-to-top element, etc. if an action
performed with a stack element and it is not pushing, then it is usually popping

by default, all instructions work with 1 byte (8 bits) at once, using flags you
can set the memory width to 2 bytes (16 bit), 4 bytes (32 bit), 8 bytes (64 bit)
, and revert to the default 1 byte/8 bit memory width. when a flag is set, it is
kept until another flag is encountered.

add/subtract instructions will overflow if memory width is too small, you should
consider using a memory width one above the width of the numbers you pushed to
A and B if you would like to avoid integer overflows.

memory deallocation is safe and does not let you wipe the first 64 bytes of mem.

instructions marked with ! are not currently implemented.

 0x | opcode     | notes
----|------------|--------------------------------------------------------------
!00 | push       | push values to stack until null byte is reached
!01 | push bytes | following program bytes will be pushed to stack
!02 | pop to A   | pop byte(s) from stack to A register
!03 | pop to B   | pop byte(s) from stack to A register
!04 | convert #  | convert last memory width to ascii number string.
----|------------|--------------------------------------------------------------
!05 | pointr set | sets memory pointer location to A
!06 | pointr loc | push memory pointer location to stack
!07 | pointr get | push memory data to stack, pushes as many bytes as width
!08 | pntr write | pop byte from stack and write it to mem address under pointer
!09 | pntr write | write B to memory address under pointer
----|------------|--------------------------------------------------------------
!0A | add        | push answer of A + B to stack
!0B | subtract   | push answer of A - B to stack
----|------------|--------------------------------------------------------------
!0C | less       | if A isn't less than B then jump to s0
!0D | less/eql   | if A isn't less than or equal to B then jump to s0
!0E | greater    | if A isn't greater than B then jump to s0
!0F | grt/eql    | if A isn't greater than or equal to B then jump to s0
!10 | equal      | if A isn't equal to B then jump to s0
!11 | jump       | set program counter to A
----|------------|--------------------------------------------------------------
 12 | 1byte flag | set memory width to 8 bits
 13 | 2byte flag | set memory width to 16 bits
 14 | 4byte flag | set memory width to 32 bits
 15 | 8byte flag | set memory width to 64 bits
----|------------|--------------------------------------------------------------
 0x | opcode     | notes
